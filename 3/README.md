# 質疑応答
## 目次
- [質疑応答](#質疑応答)
  - [目次](#目次)
  - [me](#me)
  - [lm](#lm)
    - [詳細な説明](#詳細な説明)
      - [1. `for _, salutation = range ...` の場合](#1-for-_-salutation--range--の場合)
      - [2. `for _, salutation := range ...` の場合](#2-for-_-salutation--range--の場合)
    - [まとめ](#まとめ)
  - [me](#me-1)
  - [lm](#lm-1)
  - [me](#me-2)
  - [lm](#lm-2)
    - [詳細な解説](#詳細な解説)
  - [me](#me-3)
  - [lm](#lm-3)
  - [me](#me-4)
  - [lm](#lm-4)
    - [1. nil チャネル c の役割](#1-nil-チャネル-c-の役割)
    - [2. nil チャネルでの受信操作](#2-nil-チャネルでの受信操作)
    - [3. ゴルーチンの解放されない理由](#3-ゴルーチンの解放されない理由)
    - [4. WaitGroup の役割とタイミング](#4-waitgroup-の役割とタイミング)
    - [まとめ](#まとめ-1)

## me
以下のコードを実行したとき、次の表な表示になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation = range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
good day
good day
```

ですが、以下のコード（たった一文字変えただけ）では以下のような出力になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation := range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
hello
greetings
```

これはなぜでしょうか。メモリアクセス的に言えば、大きなスコープで参照された変数はアドレスにアクセスするという認識なので、一度salutationに書きかわったら全てのゴールーチンでその文字列をprintするという事実は自然だと感じます。だって、アクセス元のsalutationが書き換わっているので。ですが、=を:=にするだけで順不同の若干直感的とも言える出力が得られました。なぜでしょうか。

## lm
この差は、forループ内で使われる変数のスコープと、クロージャがどの変数をキャプチャするかにあります。

---

### 詳細な説明

#### 1. `for _, salutation = range ...` の場合

- **動作**  
  この書き方では、既に定義されている外側の変数 `salutation` に対して、各ループで値が代入されます。  
- **クロージャのキャプチャ**  
  ゴルーチン内のクロージャは外側の `salutation` 変数そのものをキャプチャしているため、ループが進むたびにこの変数の値は更新されます。  
- **結果**  
  最後のループの値（ここでは `"good day"`）が最終的な値として残るため、すべてのゴルーチンが同じ値（`"good day"`）を参照することになります。

#### 2. `for _, salutation := range ...` の場合

- **動作**  
  この書き方では、`:=` によってループごとに**新しい変数** `salutation` が宣言されます。  
- **クロージャのキャプチャ**  
  各ループで生成された新しい変数は、そのループイテレーション内で固定された値を持つため、ゴルーチンがキャプチャする値は各イテレーションごとに異なります。  
- **結果**  
  各ゴルーチンは、ループごとの固有の `salutation` を参照するため、期待通りに各イテレーションの値（`"hello"`, `"greetings"`, `"good day"`）が出力されます。

---

### まとめ

- **`=` を使う場合**  
  → 外側の変数が使われるため、すべてのゴルーチンが最終的な更新後の値（この例では `"good day"`）を参照する。
  
- **`:=` を使う場合**  
  → 各ループイテレーションで新しい変数が作られるので、クロージャはそれぞれ固有の値をキャプチャし、期待通りの出力になる。

この違いが、あなたが観察した出力の違いの原因です。

## me
つまり、同名の変数だけど違うアドレスにアクセスしているということですか？
あと、毎回good dayになってしまうのは、ゴールーチンよりも先にforループが終了してしまうので、終了した段階で保持されているsalutationの値がgood dayだからその値のアドレスにアクセスしている以上、全部その文字列になるということでしょうか。

## lm
その理解は正しいです。

- **同名の変数でも違うアドレスにある：**  
  `:=` を使うと、ループの各イテレーションで新しいローカル変数が生成されるため、クロージャがキャプチャする変数はそれぞれ異なるアドレスにあることになります。一方、`=` を使う場合は既に存在する外側の変数を再利用しているため、すべて同じアドレスを参照します。

- **ループ終了後の値の問題：**  
  `=` の場合、forループが先に終了してしまい、最終的な値（この例では `"good day"`）が変数にセットされます。ゴルーチンはその同じ変数（同じアドレス）を参照するため、最終的に全て `"good day"` が出力される、ということになります。

この2点が、出力の違いの原因となっています。

## me
本当にそうなのですか？例えば、forループ内での処理よりもゴールーチンの終了が早かった可能性もありませんか？その場合は、出力される文字列が異なることは自然だと解釈できます。ただし、順不同なのはおかしい気もします。だって、一回でもforループの後の方の変数のゴールーチンが先に終わってしまったのならば、出力において同じ文字列が最低でも2回以上は繰り返されなければおかしいはずです。

## lm
その可能性は理論上ありえますが、実際の出力結果がそうならなかった理由は、ゴルーチンの実行タイミングと変数の更新のタイミングの組み合わせにあります。

### 詳細な解説

- **共通変数のキャプチャ（`=` の場合）**  
  forループで `for _, salutation = range ...` と書くと、外側の変数 `salutation` が使われ、各ゴルーチンはその同じアドレスを参照します。  
  - ゴルーチン内で実際に `fmt.Println(salutation)` が呼ばれるタイミングに依存して、最新の値が出力されます。  
  - この例では、forループのすべてのイテレーションが完了して、最終的に `salutation` に `"good day"` が入った状態になってから多くのゴルーチンが実行されるため、結果としてすべて `"good day"` が出力されました。

- **実行タイミングの不確定性**  
  ゴルーチンは非同期に実行されるため、あるゴルーチンがループの後半の値で実行される前に先に実行される可能性もあります。  
  - もしあるゴルーチンがループの途中で実行され、当時の値（例えば `"hello"` や `"greetings"`）を読めば、出力が混在することも考えられます。  
  - しかし今回の観察結果では、forループのすべてのイテレーションが終了してからゴルーチンがほぼまとめて動いたため、全て同じ最終値（`"good day"`）が出力されました。

- **順不同の出力について**  
  順不同になっているのは、各ゴルーチンの終了タイミングがスケジューラに依存するためです。  
  - もし1回でも後半の値を持ったゴルーチンが先に実行されれば、その時点の値が出力されます。  
  - ただし、共通変数の場合、後から値が上書きされるため、最終的にどのゴルーチンも同じ変数（同じアドレス）を見に行き、結果として同じ値になりやすくなります。

まとめると、  
- **同じ変数のアドレスを参照しているため、forループ終了後にその変数の最終値が設定されていれば、ほとんどのゴルーチンがその値を参照します。**  
- **ゴルーチンの実行タイミング次第では、途中の値を読める可能性もあるが、今回の実行ではforループが先に完了してしまい、すべて同じ値になったということです。**

このため、たとえゴルーチンが早く終了する可能性があったとしても、実際のスケジューリング次第で全体が同じ値になったり、順不同になったりするため、必ずしも同じ文字列が複数回出力されるという保証はなく、結果として今回のような出力になったというわけです。

## me
つまり、:=が別のアドレスに保持されている証拠の一つになるってことですかね？だって、一切同じ文字列を繰り返さないんですから。

## lm
その通りです。  
`:=` を使うことで、forループの各イテレーションごとに新しい変数が生成され、それぞれが独自のアドレスを持ちます。結果として、ゴルーチンがそれぞれ個別の変数をキャプチャするため、出力される文字列が各イテレーションの値（"hello", "greetings", "good day"）となり、一切同じ文字列が繰り返されないのです。

## me
なぜこのコードでゴールーチンが解放されないということが実現できるのでしょうか。特に変数cの定義やnoop関数のあたりがそれに寄与していますが、いまいち理解できていません。

```
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	memConsumed := func() uint64 {
		runtime.GC()
		var s runtime.MemStats
		runtime.ReadMemStats(&s)
		return s.Sys
	}

	var c <-chan interface{}
	var wg sync.WaitGroup
	noop := func() {
		wg.Done()
		<-c
	}

	const numGoroutines = 1e4
	wg.Add(numGoroutines)
	before := memConsumed()
	for i := numGoroutines; i > 0; i-- {
		go noop()
	}
	wg.Wait()
	after := memConsumed()
	fmt.Printf("%.3fKB\n", float64(after-before)/numGoroutines/100)
}
```

## lm
このコードでゴルーチンが解放されない（＝永久に待機状態に留まる）のは、noop 関数内で行われる受信操作が原因です。詳しく説明します。

---

### 1. nil チャネル c の役割

```go
var c <-chan interface{}
```

- ここで宣言された `c` は、受信用のチャネルですが、どこにも初期化（例えば `make(chan interface{})` などされていません）されていません。
- Go では、未初期化のチャネルは **nil チャネル** になります。

---

### 2. nil チャネルでの受信操作

```go
noop := func() {
    wg.Done()
    <-c
}
```

- この noop 関数は、まず `wg.Done()` を呼び出して WaitGroup のカウンタを減らします。
- その後、 `<-c` によって `c` から値を受信しようとしますが、`c` は nil チャネルです。
- **nil チャネルからの受信は無条件にブロックされる**ため、この行でゴルーチンは永久に待機状態に入ります。

---

### 3. ゴルーチンの解放されない理由

- ゴルーチンは、終了状態にならずにずっと `<-c` でブロックしているため、ガベージコレクションによって解放されません。
- つまり、各ゴルーチンは生存したままメモリ上に残り続け、これがメモリ使用量の増加として観察されます。

---

### 4. WaitGroup の役割とタイミング

- `wg.Add(numGoroutines)` で全ゴルーチンの開始を待ち、各ゴルーチンは `wg.Done()` を呼び出すので WaitGroup は完了します。
- しかし、WaitGroup の完了は各ゴルーチンが `wg.Done()` を呼んだ時点の話であって、その後の `<-c` のブロック状態は解決されません。

---

### まとめ

- **nil チャネル** `c` に対して `<-c` を実行すると、必ずブロック状態になります。
- そのため、各ゴルーチンは終了せずにずっと待機状態に留まり、メモリ上に残り続けます。
- この仕組みが「ゴルーチンが解放されない」という状態を実現しています。

このように、変数 `c` の定義と noop 関数内での `<-c` によって、ゴルーチンが永久にブロックされ、解放されない状態になるのです。
