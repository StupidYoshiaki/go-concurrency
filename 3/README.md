# 質疑応答
- [質疑応答](#質疑応答)
	- [me](#me)
	- [lm](#lm)
		- [詳細な説明](#詳細な説明)
			- [1. `for _, salutation = range ...` の場合](#1-for-_-salutation--range--の場合)
			- [2. `for _, salutation := range ...` の場合](#2-for-_-salutation--range--の場合)
		- [まとめ](#まとめ)
	- [me](#me-1)
	- [lm](#lm-1)
	- [me](#me-2)
	- [lm](#lm-2)
		- [詳細な解説](#詳細な解説)
	- [me](#me-3)
	- [lm](#lm-3)
	- [me](#me-4)
	- [lm](#lm-4)
		- [1. nil チャネル c の役割](#1-nil-チャネル-c-の役割)
		- [2. nil チャネルでの受信操作](#2-nil-チャネルでの受信操作)
		- [3. ゴルーチンの解放されない理由](#3-ゴルーチンの解放されない理由)
		- [4. WaitGroup の役割とタイミング](#4-waitgroup-の役割とタイミング)
		- [まとめ](#まとめ-1)
	- [me](#me-5)
	- [lm](#lm-5)
	- [me](#me-6)
	- [lm](#lm-6)
		- [コードの構造](#コードの構造)
		- [どのような事象を実験しているか](#どのような事象を実験しているか)
		- [なぜ producer、observer どちらも読み込みだけならRWMutexが常に速くならないのか](#なぜ-producerobserver-どちらも読み込みだけならrwmutexが常に速くならないのか)
		- [結論](#結論)

## me
以下のコードを実行したとき、次の表な表示になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation = range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
good day
good day
```

ですが、以下のコード（たった一文字変えただけ）では以下のような出力になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation := range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
hello
greetings
```

これはなぜでしょうか。メモリアクセス的に言えば、大きなスコープで参照された変数はアドレスにアクセスするという認識なので、一度salutationに書きかわったら全てのゴールーチンでその文字列をprintするという事実は自然だと感じます。だって、アクセス元のsalutationが書き換わっているので。ですが、=を:=にするだけで順不同の若干直感的とも言える出力が得られました。なぜでしょうか。

## lm
この差は、forループ内で使われる変数のスコープと、クロージャがどの変数をキャプチャするかにあります。

---

### 詳細な説明

#### 1. `for _, salutation = range ...` の場合

- **動作**  
  この書き方では、既に定義されている外側の変数 `salutation` に対して、各ループで値が代入されます。  
- **クロージャのキャプチャ**  
  ゴルーチン内のクロージャは外側の `salutation` 変数そのものをキャプチャしているため、ループが進むたびにこの変数の値は更新されます。  
- **結果**  
  最後のループの値（ここでは `"good day"`）が最終的な値として残るため、すべてのゴルーチンが同じ値（`"good day"`）を参照することになります。

#### 2. `for _, salutation := range ...` の場合

- **動作**  
  この書き方では、`:=` によってループごとに**新しい変数** `salutation` が宣言されます。  
- **クロージャのキャプチャ**  
  各ループで生成された新しい変数は、そのループイテレーション内で固定された値を持つため、ゴルーチンがキャプチャする値は各イテレーションごとに異なります。  
- **結果**  
  各ゴルーチンは、ループごとの固有の `salutation` を参照するため、期待通りに各イテレーションの値（`"hello"`, `"greetings"`, `"good day"`）が出力されます。

---

### まとめ

- **`=` を使う場合**  
  → 外側の変数が使われるため、すべてのゴルーチンが最終的な更新後の値（この例では `"good day"`）を参照する。
  
- **`:=` を使う場合**  
  → 各ループイテレーションで新しい変数が作られるので、クロージャはそれぞれ固有の値をキャプチャし、期待通りの出力になる。

この違いが、あなたが観察した出力の違いの原因です。

## me
つまり、同名の変数だけど違うアドレスにアクセスしているということですか？
あと、毎回good dayになってしまうのは、ゴールーチンよりも先にforループが終了してしまうので、終了した段階で保持されているsalutationの値がgood dayだからその値のアドレスにアクセスしている以上、全部その文字列になるということでしょうか。

## lm
その理解は正しいです。

- **同名の変数でも違うアドレスにある：**  
  `:=` を使うと、ループの各イテレーションで新しいローカル変数が生成されるため、クロージャがキャプチャする変数はそれぞれ異なるアドレスにあることになります。一方、`=` を使う場合は既に存在する外側の変数を再利用しているため、すべて同じアドレスを参照します。

- **ループ終了後の値の問題：**  
  `=` の場合、forループが先に終了してしまい、最終的な値（この例では `"good day"`）が変数にセットされます。ゴルーチンはその同じ変数（同じアドレス）を参照するため、最終的に全て `"good day"` が出力される、ということになります。

この2点が、出力の違いの原因となっています。

## me
本当にそうなのですか？例えば、forループ内での処理よりもゴールーチンの終了が早かった可能性もありませんか？その場合は、出力される文字列が異なることは自然だと解釈できます。ただし、順不同なのはおかしい気もします。だって、一回でもforループの後の方の変数のゴールーチンが先に終わってしまったのならば、出力において同じ文字列が最低でも2回以上は繰り返されなければおかしいはずです。

## lm
その可能性は理論上ありえますが、実際の出力結果がそうならなかった理由は、ゴルーチンの実行タイミングと変数の更新のタイミングの組み合わせにあります。

### 詳細な解説

- **共通変数のキャプチャ（`=` の場合）**  
  forループで `for _, salutation = range ...` と書くと、外側の変数 `salutation` が使われ、各ゴルーチンはその同じアドレスを参照します。  
  - ゴルーチン内で実際に `fmt.Println(salutation)` が呼ばれるタイミングに依存して、最新の値が出力されます。  
  - この例では、forループのすべてのイテレーションが完了して、最終的に `salutation` に `"good day"` が入った状態になってから多くのゴルーチンが実行されるため、結果としてすべて `"good day"` が出力されました。

- **実行タイミングの不確定性**  
  ゴルーチンは非同期に実行されるため、あるゴルーチンがループの後半の値で実行される前に先に実行される可能性もあります。  
  - もしあるゴルーチンがループの途中で実行され、当時の値（例えば `"hello"` や `"greetings"`）を読めば、出力が混在することも考えられます。  
  - しかし今回の観察結果では、forループのすべてのイテレーションが終了してからゴルーチンがほぼまとめて動いたため、全て同じ最終値（`"good day"`）が出力されました。

- **順不同の出力について**  
  順不同になっているのは、各ゴルーチンの終了タイミングがスケジューラに依存するためです。  
  - もし1回でも後半の値を持ったゴルーチンが先に実行されれば、その時点の値が出力されます。  
  - ただし、共通変数の場合、後から値が上書きされるため、最終的にどのゴルーチンも同じ変数（同じアドレス）を見に行き、結果として同じ値になりやすくなります。

まとめると、  
- **同じ変数のアドレスを参照しているため、forループ終了後にその変数の最終値が設定されていれば、ほとんどのゴルーチンがその値を参照します。**  
- **ゴルーチンの実行タイミング次第では、途中の値を読める可能性もあるが、今回の実行ではforループが先に完了してしまい、すべて同じ値になったということです。**

このため、たとえゴルーチンが早く終了する可能性があったとしても、実際のスケジューリング次第で全体が同じ値になったり、順不同になったりするため、必ずしも同じ文字列が複数回出力されるという保証はなく、結果として今回のような出力になったというわけです。

## me
つまり、:=が別のアドレスに保持されている証拠の一つになるってことですかね？だって、一切同じ文字列を繰り返さないんですから。

## lm
その通りです。  
`:=` を使うことで、forループの各イテレーションごとに新しい変数が生成され、それぞれが独自のアドレスを持ちます。結果として、ゴルーチンがそれぞれ個別の変数をキャプチャするため、出力される文字列が各イテレーションの値（"hello", "greetings", "good day"）となり、一切同じ文字列が繰り返されないのです。

## me
なぜこのコードでゴールーチンが解放されないということが実現できるのでしょうか。特に変数cの定義やnoop関数のあたりがそれに寄与していますが、いまいち理解できていません。

```
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	memConsumed := func() uint64 {
		runtime.GC()
		var s runtime.MemStats
		runtime.ReadMemStats(&s)
		return s.Sys
	}

	var c <-chan interface{}
	var wg sync.WaitGroup
	noop := func() {
		wg.Done()
		<-c
	}

	const numGoroutines = 1e4
	wg.Add(numGoroutines)
	before := memConsumed()
	for i := numGoroutines; i > 0; i-- {
		go noop()
	}
	wg.Wait()
	after := memConsumed()
	fmt.Printf("%.3fKB\n", float64(after-before)/numGoroutines/100)
}
```

## lm
このコードでゴルーチンが解放されない（＝永久に待機状態に留まる）のは、noop 関数内で行われる受信操作が原因です。詳しく説明します。

---

### 1. nil チャネル c の役割

```go
var c <-chan interface{}
```

- ここで宣言された `c` は、受信用のチャネルですが、どこにも初期化（例えば `make(chan interface{})` などされていません）されていません。
- Go では、未初期化のチャネルは **nil チャネル** になります。

---

### 2. nil チャネルでの受信操作

```go
noop := func() {
    wg.Done()
    <-c
}
```

- この noop 関数は、まず `wg.Done()` を呼び出して WaitGroup のカウンタを減らします。
- その後、 `<-c` によって `c` から値を受信しようとしますが、`c` は nil チャネルです。
- **nil チャネルからの受信は無条件にブロックされる**ため、この行でゴルーチンは永久に待機状態に入ります。

---

### 3. ゴルーチンの解放されない理由

- ゴルーチンは、終了状態にならずにずっと `<-c` でブロックしているため、ガベージコレクションによって解放されません。
- つまり、各ゴルーチンは生存したままメモリ上に残り続け、これがメモリ使用量の増加として観察されます。

---

### 4. WaitGroup の役割とタイミング

- `wg.Add(numGoroutines)` で全ゴルーチンの開始を待ち、各ゴルーチンは `wg.Done()` を呼び出すので WaitGroup は完了します。
- しかし、WaitGroup の完了は各ゴルーチンが `wg.Done()` を呼んだ時点の話であって、その後の `<-c` のブロック状態は解決されません。

---

### まとめ

- **nil チャネル** `c` に対して `<-c` を実行すると、必ずブロック状態になります。
- そのため、各ゴルーチンは終了せずにずっと待機状態に留まり、メモリ上に残り続けます。
- この仕組みが「ゴルーチンが解放されない」という状態を実現しています。

このように、変数 `c` の定義と noop 関数内での `<-c` によって、ゴルーチンが永久にブロックされ、解放されない状態になるのです。

## me
このコードにおいて、beginチャネルが送信を開始し始めるのはどのタイミングですか？関数を定義した段階では呼び出されないと思いますし、begin変数を定義した段階ではまだ関数が定義されていない状態です。なので、ゴールーチンとして関数を実行した時でしょうか？教えてください。

```
package main_test

import (
	"sync"
	"testing"
)

func BenchmarkContextSwitch(b *testing.B) {
	var wg sync.WaitGroup
	begin := make(chan struct{})
	c := make(chan struct{})

	var token struct{}
	sender := func() {
		defer wg.Done()
		<-begin
		for i := 0; i < b.N; i++ {
			c <- token
		}
	}
	receiver := func() {
		defer wg.Done()
		<-begin
		for i := 0; i < b.N; i++ {
			<-c
		}
	}

	wg.Add(2)
	go sender()
	go receiver()
	b.StartTimer()
	close(begin)
	wg.Wait()
}
```

## lm
このコードでは、begin チャネルはゴルーチン内の sender と receiver で最初に `<-begin` として受信待ちされ、b.StartTimer() の直後に close(begin) が呼ばれることで、待機していた両ゴルーチンが一斉にブロックから解放され、処理を開始します。

つまり、begin チャネルからの「送信」は、関数定義や変数宣言の段階ではなく、実際にゴルーチンが走り始めた後、b.StartTimer() の直後に close(begin) が実行されたときに発生する、ということです。

## me
このコードについて説明してください。どのような事象を実験できているのでしょうか。producer、observer関数はどちらも読み込みだけを必要としているから、専有ロックするよりも動作が早くなるということでしょうか。それなら、全ての事象において結果はRWの方が早くなるはずです。解説お願いします。

```
func rwMutex() {
	producer := func(wg *sync.WaitGroup, l sync.Locker) {
		defer wg.Done()
		for i := 0; i < 5; i++ {
			l.Lock()
			l.Unlock()
			time.Sleep(1)
		}
	}

	observer := func(wg *sync.WaitGroup, l sync.Locker) {
		defer wg.Done()
		l.Lock()
		defer l.Unlock()
	}

	test := func(count int, mutex, rwMutex sync.Locker) time.Duration {
		var wg sync.WaitGroup
		wg.Add(count + 1)
		beginTestTime := time.Now()
		go producer(&wg, mutex)
		for i := count; i > 0; i-- {
			go observer(&wg, rwMutex)
		}

		wg.Wait()
		return time.Since(beginTestTime)
	}

	tw := tabwriter.NewWriter(os.Stdout, 0, 1, 2, ' ', 0)
	defer tw.Flush()

	var m sync.RWMutex
	fmt.Fprintf(tw, "Readers\tRWMutex\tMutex\n")
	for i := 0; i < 20; i++ {
		count := int(math.Pow(2, float64(i)))
		fmt.Fprintf(
			tw,
			"%d\t%v\t%v\n",
			count,
			test(count, &m, m.RLocker()),
			test(count, &m, &m),
		)
	}

}
```
```
Readers  RWMutex      Mutex
1        98.167µs     18.583µs
2        12.042µs     12.375µs
4        8.042µs      4.375µs
8        14.25µs      9.375µs
16       21.542µs     11.5µs
32       21.25µs      40.375µs
64       36.917µs     54.75µs
128      49.333µs     35.25µs
256      79.792µs     78.833µs
512      165.625µs    124µs
1024     228.5µs      264.583µs
2048     495.375µs    496.875µs
4096     1.010542ms   1.020875ms
8192     1.802375ms   1.682958ms
16384    3.325167ms   6.516417ms
32768    7.412333ms   9.03025ms
65536    14.018625ms  18.135375ms
131072   27.562084ms  35.904583ms
262144   56.4725ms    71.956709ms
524288   111.8665ms   144.712708ms
```

## lm
このコードは、1つの「producer」と多数の「observer」が同じミューテックスを使ってアクセスする状況で、排他ロック（Mutex）と読み取り専用ロック（RWMutexのRLocker()）の性能の違いがどのようにスケールするかを実験しています。

---

### コードの構造

1. **producer 関数**  
   - 5回のループで、毎回ロックとアンロックを行い、その後短いスリープ（time.Sleep(1)）を挟みます。  
   - この関数は常に「専有」ロックを使います（test 関数の引数として渡される `mutex` は &m です）。

2. **observer 関数**  
   - 1回だけロックとアンロックを行います。  
   - ここで、test 関数に渡されるロッカー `l` は、実験によって2通りです。  
     - 1つは `m.RLocker()`（RWMutexの読み取りロック）  
     - もう1つは `&m`（通常のMutexによる排他ロック）

3. **test 関数**  
   - 指定された数（count）だけ observer をゴルーチンとして起動し、同時に1つの producer も起動します。  
   - 処理開始直前に b.StartTimer() を呼び、直後に begin チャネルを close して、producer と observer の両方が同時に動き出すようにしています。  
   - 全てのゴルーチンが完了するまで待機し、経過時間を返します。

4. **ベンチマーク実行部**  
   - 観測者（observer）の数を 2^0 から 2^19（1〜524288）まで変化させながら、RWMutex と Mutex のそれぞれのロック方式で test を実行し、かかった時間を比較しています。

---

### どのような事象を実験しているか

- **読み取り専用ロック vs 排他ロックの性能比較**  
  観測者は単にロックを取得してすぐ解放するだけの操作なので、データの書き換えなどは行いません。  
  - RWMutex の RLocker() は複数のゴルーチンが同時に読み取りを行う場合、同時実行が可能です。  
  - 一方、通常の Mutex は排他制御なので、たとえ読み込みだけでも順番に実行されます。

- **スケールとオーバーヘッドの関係**  
  - 観測者の数が少ない場合、RWMutex の内部処理は通常の Mutex よりも複雑なため、かえってわずかに遅くなることもあります。  
  - しかし、観測者が多くなると、複数のゴルーチンが同時に読み取りロックを取得できるメリットが発揮され、全体としては RWMutex の方が高速になる傾向が見られます。

---

### なぜ producer、observer どちらも読み込みだけならRWMutexが常に速くならないのか

- **producer は排他ロックを使う**  
  producer の処理では、ロックとアンロックの繰り返しと短い待ち（time.Sleep）が入っています。  
  この処理は RWMutex を使う場合でも通常の Mutex と同じ排他ロック（書き込みロック）を使用するので、どちらのケースでも同じです。

- **observer のみが差異の対象**  
  observer は、RWMutex を使う場合は読み取り専用ロックを取得でき、複数の observer が同時にロックを保持できるというメリットがあります。  
  ただし、observer の処理自体が非常に短い（ロックしてすぐ解放するだけ）ため、ロック取得のオーバーヘッドが RWMutex の内部処理のコストに近づく場合、読取専用ロックが必ずしも圧倒的に速くなるとは限りません。

- **結果としての挙動**  
  実験結果の表からも分かるように、観測者の数や状況により、RWMutex と Mutex のどちらが速いかは変動します。  
  つまり、読み込みのみの場合でも、システムの負荷やロックの取得コストの相対的なオーバーヘッド次第で、必ずしも RWMutex の方が一律に速いというわけではないということです。

---

### 結論

このコードは、単一の書き込み（producer）と多数の読み込み（observer）というシナリオにおいて、RWMutex（読み取り専用ロックを利用）と通常のMutex（排他ロックのみ）のパフォーマンスの違いを測定しています。  
- **読み込みだけの場合、理論上は複数同時にアクセスできる RWMutex にメリットがありますが、ロックのオーバーヘッドやシナリオ全体の構成により、常に速いとは限らない**という点を示しています。
