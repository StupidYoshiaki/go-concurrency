# 質疑応答
## 目次
- [質疑応答](#質疑応答)
  - [目次](#目次)
  - [me](#me)
  - [lm](#lm)
    - [詳細な説明](#詳細な説明)
      - [1. `for _, salutation = range ...` の場合](#1-for-_-salutation--range--の場合)
      - [2. `for _, salutation := range ...` の場合](#2-for-_-salutation--range--の場合)
    - [まとめ](#まとめ)
  - [me](#me-1)
  - [lm](#lm-1)

## me
以下のコードを実行したとき、次の表な表示になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation = range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
good day
good day
```

ですが、以下のコード（たった一文字変えただけ）では以下のような出力になります。
```
// welcome を返す
	// スコープの中で使われている変数をさらに小さいスコープ（ゴールーチン）で読み出す場合はアドレスを参照
	salutation := "hello"
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		salutation = "welcome"
	}()
	wg.Wait()
	fmt.Println(salutation)

	// ランダムに値を返す
	for _, salutation := range []string{"hello", "greetings", "good day"} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			fmt.Println(salutation)
		}()
	}
	wg.Wait()
```
```
welcome
good day
hello
greetings
```

これはなぜでしょうか。メモリアクセス的に言えば、大きなスコープで参照された変数はアドレスにアクセスするという認識なので、一度salutationに書きかわったら全てのゴールーチンでその文字列をprintするという事実は自然だと感じます。だって、アクセス元のsalutationが書き換わっているので。ですが、=を:=にするだけで順不同の若干直感的とも言える出力が得られました。なぜでしょうか。

## lm
この差は、forループ内で使われる変数のスコープと、クロージャがどの変数をキャプチャするかにあります。

---

### 詳細な説明

#### 1. `for _, salutation = range ...` の場合

- **動作**  
  この書き方では、既に定義されている外側の変数 `salutation` に対して、各ループで値が代入されます。  
- **クロージャのキャプチャ**  
  ゴルーチン内のクロージャは外側の `salutation` 変数そのものをキャプチャしているため、ループが進むたびにこの変数の値は更新されます。  
- **結果**  
  最後のループの値（ここでは `"good day"`）が最終的な値として残るため、すべてのゴルーチンが同じ値（`"good day"`）を参照することになります。

#### 2. `for _, salutation := range ...` の場合

- **動作**  
  この書き方では、`:=` によってループごとに**新しい変数** `salutation` が宣言されます。  
- **クロージャのキャプチャ**  
  各ループで生成された新しい変数は、そのループイテレーション内で固定された値を持つため、ゴルーチンがキャプチャする値は各イテレーションごとに異なります。  
- **結果**  
  各ゴルーチンは、ループごとの固有の `salutation` を参照するため、期待通りに各イテレーションの値（`"hello"`, `"greetings"`, `"good day"`）が出力されます。

---

### まとめ

- **`=` を使う場合**  
  → 外側の変数が使われるため、すべてのゴルーチンが最終的な更新後の値（この例では `"good day"`）を参照する。
  
- **`:=` を使う場合**  
  → 各ループイテレーションで新しい変数が作られるので、クロージャはそれぞれ固有の値をキャプチャし、期待通りの出力になる。

この違いが、あなたが観察した出力の違いの原因です。

## me
つまり、同名の変数だけど違うアドレスにアクセスしているということですか？
あと、毎回good dayになってしまうのは、ゴールーチンよりも先にforループが終了してしまうので、終了した段階で保持されているsalutationの値がgood dayだからその値のアドレスにアクセスしている以上、全部その文字列になるということでしょうか。

## lm
その理解は正しいです。

- **同名の変数でも違うアドレスにある：**  
  `:=` を使うと、ループの各イテレーションで新しいローカル変数が生成されるため、クロージャがキャプチャする変数はそれぞれ異なるアドレスにあることになります。一方、`=` を使う場合は既に存在する外側の変数を再利用しているため、すべて同じアドレスを参照します。

- **ループ終了後の値の問題：**  
  `=` の場合、forループが先に終了してしまい、最終的な値（この例では `"good day"`）が変数にセットされます。ゴルーチンはその同じ変数（同じアドレス）を参照するため、最終的に全て `"good day"` が出力される、ということになります。

この2点が、出力の違いの原因となっています。
